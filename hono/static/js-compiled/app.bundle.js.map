{"version":3,"file":"app.bundle.js","mappings":";;;;;;;;;;;AAgBA;;;;;;;;;;;;;;;GAeG;AACH,SAAS,sBAAsB,CAA+B,EAC5D,cAAc,GAAG,KAAK,EACtB,MAAM,GAAG,KAAK,EACd,OAAO,GAAG,IAAI,GACf,GAAG,EAAE;IAEJ,eAAe,EAAE,CAAC;IAElB,IAAI,OAAO,GAAG,KAAK,CAAC;IAEpB,OAAO,IAAI,OAAO,CAAC,CAAC,OAAO,EAAE,EAAE;QAC7B,IAAK,MAAiB,CAAC,QAAQ,EAAE;YAE/B,cAAc,EAAE,CAAC;SAElB;aAAM;YAEL,MAAM,CAAC,gBAAgB,CACrB,sBAAsB,EACtB,cAAc,EACd,EAAE,IAAI,EAAE,IAAI,EAAE,CACf,CAAC;YAEF,UAAU,CAAC,GAAG,EAAE;gBACd,cAAc,EAAE,CAAC;YACnB,CAAC,EAAE,OAAO,CAAC,CAAC;SACb;QAED,SAAS,cAAc;YAErB,IAAI,OAAO,EAAE;gBACX,OAAO;aACR;YACD,OAAO,GAAG,IAAI,CAAC;YAEf,MAAM,CAAC,mBAAmB,CAAC,sBAAsB,EAAE,cAAc,CAAC,CAAC;YAEnE,MAAM,EAAE,QAAQ,EAAE,GAAG,MAAgB,CAAC;YAEtC,IAAI,QAAQ,IAAI,CAAC,CAAC,cAAc,IAAI,QAAQ,CAAC,UAAU,CAAC,EAAE;gBACxD,OAAO,CAAC,QAAwB,CAAC,CAAC;aACnC;iBAAM;gBAEL,MAAM,OAAO,GAAG,cAAc,IAAI,QAAQ;oBACxC,CAAC,CAAC,wCAAwC;oBAC1C,CAAC,CAAC,mCAAmC,CAAC;gBAExC,CAAC,MAAM,IAAI,OAAO,CAAC,KAAK,CAAC,4BAA4B,EAAE,OAAO,CAAC,CAAC;gBAChE,OAAO,CAAC,IAAI,CAAC,CAAC;aACf;QACH,CAAC;IACH,CAAC,CAAC,CAAC;IAEH,SAAS,eAAe;QACtB,IAAI,OAAO,cAAc,KAAK,SAAS,EAAE;YACvC,MAAM,IAAI,KAAK,CAAC,8EAA8E,CAAC,CAAC;SACjG;QACD,IAAI,OAAO,MAAM,KAAK,SAAS,EAAE;YAC/B,MAAM,IAAI,KAAK,CAAC,sEAAsE,CAAC,CAAC;SACzF;QACD,IAAI,OAAO,OAAO,KAAK,QAAQ,EAAE;YAC/B,MAAM,IAAI,KAAK,CAAC,sEAAsE,CAAC,CAAC;SACzF;IACH,CAAC;AACH,CAAC;AAlFD,iBAAS,sBAAsB,CAAC;;;;;;;;;;;;;;;;;;;;;;;;ACdhC,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACA,mBAAmB,SAAI,IAAI,SAAI;AAC/B,cAAc,6BAA6B,0BAA0B,cAAc,qBAAqB;AACxG,6IAA6I,cAAc;AAC3J,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC,mCAAmC,SAAS;AAC5C,mCAAmC,WAAW,UAAU;AACxD,0CAA0C,cAAc;AACxD;AACA,8GAA8G,OAAO;AACrH,iFAAiF,iBAAiB;AAClG,yDAAyD,gBAAgB,QAAQ;AACjF,+CAA+C,gBAAgB,gBAAgB;AAC/E;AACA,kCAAkC;AAClC;AACA;AACA,UAAU,YAAY,aAAa,SAAS,UAAU;AACtD,oCAAoC,SAAS;AAC7C;AACA;AAC+D;AAC/D;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,kBAAkB;AACzD,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,kFAAkF,wDAAwD;AAC1I;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA,6BAA6B;AAC7B,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,kBAAkB;AACzD,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,gEAAsB;AAC/D;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,uBAAuB;AAChE;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,yCAAyC,uBAAuB;AAChE;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,yCAAyC,uBAAuB;AAChE;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,yCAAyC,uBAAuB;AAChE;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,kBAAkB;AACzD,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,kFAAkF,wDAAwD;AAC1I;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;;;;;;;;;;;;;;;;;ACleA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACA,mBAAmB,SAAI,IAAI,SAAI;AAC/B,cAAc,6BAA6B,0BAA0B,cAAc,qBAAqB;AACxG,6IAA6I,cAAc;AAC3J,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC,mCAAmC,SAAS;AAC5C,mCAAmC,WAAW,UAAU;AACxD,0CAA0C,cAAc;AACxD;AACA,8GAA8G,OAAO;AACrH,iFAAiF,iBAAiB;AAClG,yDAAyD,gBAAgB,QAAQ;AACjF,+CAA+C,gBAAgB,gBAAgB;AAC/E;AACA,kCAAkC;AAClC;AACA;AACA,UAAU,YAAY,aAAa,SAAS,UAAU;AACtD,oCAAoC,SAAS;AAC7C;AACA;AACsC;AACV;AAC5B;AACA;AACA,IAAI,8CAAK;AACT;AACA,YAAY,8CAAK;AACjB;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT,KAAK;AACL,IAAI,8CAAK;AACT;AACA,uDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,+CAAQ,KAAK,+CAAQ;AAClD,4BAA4B,8CAAK;AACjC;AACA;AACA,wCAAwC,+CAAQ;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,8CAAK;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,8CAAK;AAC7B;AACA;AACA;AACA;AACA,wBAAwB,8CAAK;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS,IAAI;AACb,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,+CAAQ;AACjC;AACA;AACA,yCAAyC,+CAAQ;AACjD;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA,iEAAe,OAAO,EAAC;;;;;;;;;;;;;;;;ACpKvB,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACA,mBAAmB,SAAI,IAAI,SAAI;AAC/B,cAAc,6BAA6B,0BAA0B,cAAc,qBAAqB;AACxG,6IAA6I,cAAc;AAC3J,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC,mCAAmC,SAAS;AAC5C,mCAAmC,WAAW,UAAU;AACxD,0CAA0C,cAAc;AACxD;AACA,8GAA8G,OAAO;AACrH,iFAAiF,iBAAiB;AAClG,yDAAyD,gBAAgB,QAAQ;AACjF,+CAA+C,gBAAgB,gBAAgB;AAC/E;AACA,kCAAkC;AAClC;AACA;AACA,UAAU,YAAY,aAAa,SAAS,UAAU;AACtD,oCAAoC,SAAS;AAC7C;AACA;AACsC;AACtC;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,GAAG;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA,gTAAgT,oFAAoF;AACpY;AACA,oDAAoD,WAAW;AAC/D;AACA,oDAAoD,WAAW;AAC/D;AACA,oDAAoD,WAAW;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,+CAAQ,aAAa,+CAAQ,uBAAuB,+CAAQ;AAC/G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,2BAA2B;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,aAAa;AACb,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,gBAAgB,kBAAkB,yBAAyB,wGAAwG,mBAAmB,yBAAyB,oBAAoB,oCAAoC;AAC/T;AACA;AACA;AACA,iCAAiC,+BAA+B;AAChE,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,KAAK,EAAC;;;;;;;;;;;;;;;;ACrPO;AAC5B;AACA,IAAI,8CAAK;AACT;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA,iEAAe,SAAS,EAAC;;;;;;;UCXzB;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA;WACA,iCAAiC,WAAW;WAC5C;WACA;;;;;WCPA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;;;;ACNA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACA,mBAAmB,SAAI,IAAI,SAAI;AAC/B,cAAc,6BAA6B,0BAA0B,cAAc,qBAAqB;AACxG,6IAA6I,cAAc;AAC3J,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC,mCAAmC,SAAS;AAC5C,mCAAmC,WAAW,UAAU;AACxD,0CAA0C,cAAc;AACxD;AACA,8GAA8G,OAAO;AACrH,iFAAiF,iBAAiB;AAClG,yDAAyD,gBAAgB,QAAQ;AACjF,+CAA+C,gBAAgB,gBAAgB;AAC/E;AACA,kCAAkC;AAClC;AACA;AACA,UAAU,YAAY,aAAa,SAAS,UAAU;AACtD,oCAAoC,SAAS;AAC7C;AACA;AACA;AACgI;AAChG;AACJ;AACQ;AACpC;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA,gBAAgB,gDAAO;AACvB,gBAAgB,kDAAS;AACzB;AACA;AACA;AACA;AACA,qCAAqC,8DAAmB;AACxD;AACA;AACA;AACA;AACA,qCAAqC,yDAAc;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,8CAAK;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0EAA0E;AAC1E;AACA;AACA,6DAA6D,8CAAK;AAClE;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA,yBAAyB;AACzB,qBAAqB,IAAI;AACzB;AACA;AACA;AACA,2EAA2E;AAC3E;AACA;AACA;AACA;AACA,oDAAoD,+CAAQ,aAAa,+CAAQ,uBAAuB,+CAAQ;AAChH,yDAAyD,8CAAK;AAC9D;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA,yBAAyB;AACzB,qBAAqB,IAAI;AACzB;AACA;AACA,sEAAsE;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,+CAAQ,aAAa,+CAAQ,uBAAuB,+CAAQ;AAC5G;AACA;AACA;AACA;AACA,qDAAqD,8CAAK;AAC1D;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB,IAAI;AACrB;AACA;AACA,0EAA0E;AAC1E;AACA;AACA;AACA,6DAA6D,4DAAiB;AAC9E;AACA;AACA;AACA,yDAAyD,2DAAgB;AACzE;AACA;AACA;AACA,6DAA6D,wDAAa;AAC1E;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,qBAAqB,IAAI;AACzB;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC,IAAI;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,+CAAQ,aAAa,+CAAQ,uBAAuB,+CAAQ;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,8CAAK;AAClD;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,6CAA6C,8CAAK;AAClD;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,8CAAK;AAC9C;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,6CAA6C,8CAAK;AAClD;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA,IAAI,8CAAK;AACT,CAAC;AACD;AACA;AACA;AACA;AACA","sources":["webpack://hono/./node_modules/@metamask/detect-provider/src/index.ts","webpack://hono/./static/ts-front-end/metamask.ts","webpack://hono/./static/ts-front-end/profile.ts","webpack://hono/./static/ts-front-end/utils.ts","webpack://hono/./static/ts-front-end/watchlist.ts","webpack://hono/webpack/bootstrap","webpack://hono/webpack/runtime/compat get default export","webpack://hono/webpack/runtime/define property getters","webpack://hono/webpack/runtime/hasOwnProperty shorthand","webpack://hono/webpack/runtime/make namespace object","webpack://hono/./static/ts-front-end/app.ts"],"sourcesContent":["interface MetaMaskEthereumProvider {\n  isMetaMask?: boolean;\n  once(eventName: string | symbol, listener: (...args: any[]) => void): this;\n  on(eventName: string | symbol, listener: (...args: any[]) => void): this;\n  off(eventName: string | symbol, listener: (...args: any[]) => void): this;\n  addListener(eventName: string | symbol, listener: (...args: any[]) => void): this;\n  removeListener(eventName: string | symbol, listener: (...args: any[]) => void): this;\n  removeAllListeners(event?: string | symbol): this;\n}\n\ninterface Window {\n  ethereum?: MetaMaskEthereumProvider;\n}\n\nexport = detectEthereumProvider;\n\n/**\n * Returns a Promise that resolves to the value of window.ethereum if it is\n * set within the given timeout, or null.\n * The Promise will not reject, but an error will be thrown if invalid options\n * are provided.\n *\n * @param options - Options bag.\n * @param options.mustBeMetaMask - Whether to only look for MetaMask providers.\n * Default: false\n * @param options.silent - Whether to silence console errors. Does not affect\n * thrown errors. Default: false\n * @param options.timeout - Milliseconds to wait for 'ethereum#initialized' to\n * be dispatched. Default: 3000\n * @returns A Promise that resolves with the Provider if it is detected within\n * given timeout, otherwise null.\n */\nfunction detectEthereumProvider<T = MetaMaskEthereumProvider>({\n  mustBeMetaMask = false,\n  silent = false,\n  timeout = 3000,\n} = {}): Promise<T | null> {\n\n  _validateInputs();\n\n  let handled = false;\n\n  return new Promise((resolve) => {\n    if ((window as Window).ethereum) {\n\n      handleEthereum();\n\n    } else {\n\n      window.addEventListener(\n        'ethereum#initialized',\n        handleEthereum,\n        { once: true },\n      );\n\n      setTimeout(() => {\n        handleEthereum();\n      }, timeout);\n    }\n\n    function handleEthereum() {\n\n      if (handled) {\n        return;\n      }\n      handled = true;\n\n      window.removeEventListener('ethereum#initialized', handleEthereum);\n\n      const { ethereum } = window as Window;\n\n      if (ethereum && (!mustBeMetaMask || ethereum.isMetaMask)) {\n        resolve(ethereum as unknown as T);\n      } else {\n\n        const message = mustBeMetaMask && ethereum\n          ? 'Non-MetaMask window.ethereum detected.'\n          : 'Unable to detect window.ethereum.';\n\n        !silent && console.error('@metamask/detect-provider:', message);\n        resolve(null);\n      }\n    }\n  });\n\n  function _validateInputs() {\n    if (typeof mustBeMetaMask !== 'boolean') {\n      throw new Error(`@metamask/detect-provider: Expected option 'mustBeMetaMask' to be a boolean.`);\n    }\n    if (typeof silent !== 'boolean') {\n      throw new Error(`@metamask/detect-provider: Expected option 'silent' to be a boolean.`);\n    }\n    if (typeof timeout !== 'number') {\n      throw new Error(`@metamask/detect-provider: Expected option 'timeout' to be a number.`);\n    }\n  }\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === \"function\" ? Iterator : Object).prototype);\n    return g.next = verb(0), g[\"throw\"] = verb(1), g[\"return\"] = verb(2), typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nimport detectEthereumProvider from \"@metamask/detect-provider\";\n// MetaMask provider detection and handling\nexport var provider = null;\n// Track connection timestamp for expiry (this is just for our 7-day rule)\nvar CONNECTION_TIME_KEY = \"metamask_connection_time\";\n// Arbitrum One network configuration\nvar ARBITRUM_NETWORK = {\n    chainId: \"0xa4b1\", // 42161 in hex\n    chainName: \"Arbitrum One\",\n    nativeCurrency: {\n        name: \"Ethereum\",\n        symbol: \"ETH\",\n        decimals: 18,\n    },\n    rpcUrls: [\"https://arb1.arbitrum.io/rpc\"],\n    blockExplorerUrls: [\"https://arbiscan.io/\"],\n};\nfunction updateNetworkStatus(chainId) {\n    var networkStatus = document.getElementById(\"networkStatus\");\n    if (!networkStatus)\n        return;\n    if (chainId === ARBITRUM_NETWORK.chainId) {\n        networkStatus.textContent = \"✅ Arbitrum One\";\n        networkStatus.style.color = \"green\";\n    }\n    else {\n        networkStatus.textContent = \"⚠️ Wrong Network\";\n        networkStatus.style.color = \"orange\";\n    }\n}\nexport function updateWalletUI() {\n    return __awaiter(this, void 0, void 0, function () {\n        var connectButton, connected, buttonTextElement, svgElement, textNode, walletAddress, networkStatus, address;\n        return __generator(this, function (_a) {\n            connectButton = document.getElementById(\"connectButton\");\n            if (!connectButton)\n                return [2 /*return*/];\n            connected = (provider === null || provider === void 0 ? void 0 : provider.isConnected()) && provider.selectedAddress;\n            console.log(\"Updating wallet UI, connected: \".concat(connected));\n            buttonTextElement = connectButton.querySelector(\"p\") || connectButton;\n            if (buttonTextElement.tagName === \"P\") {\n                buttonTextElement.textContent = connected\n                    ? \"Disconnect Wallet\"\n                    : \"Connect Wallet\";\n            }\n            else {\n                svgElement = connectButton.querySelector(\"svg\");\n                connectButton.innerHTML = \"\";\n                if (svgElement) {\n                    connectButton.appendChild(svgElement);\n                }\n                textNode = document.createTextNode(connected ? \"Disconnect Wallet\" : \"Connect Wallet\");\n                connectButton.appendChild(textNode);\n            }\n            walletAddress = document.getElementById(\"walletAddress\");\n            networkStatus = document.getElementById(\"networkStatus\");\n            if (!walletAddress || !networkStatus) {\n                console.warn(\"Wallet info elements not found in DOM\");\n                return [2 /*return*/];\n            }\n            if (connected) {\n                address = provider.selectedAddress;\n                // Update wallet address display\n                walletAddress.textContent = \"\".concat(address.slice(0, 6), \"...\").concat(address.slice(-4));\n                walletAddress.classList.remove(\"hidden\");\n                // Update network status\n                networkStatus.classList.remove(\"hidden\");\n                try {\n                    if (provider && provider.isMetaMask) {\n                        updateNetworkStatus(provider.chainId || \"\");\n                    }\n                }\n                catch (error) {\n                    console.error(\"Error getting chain ID:\", error);\n                    networkStatus.textContent = \"❌ Network Error\";\n                    networkStatus.style.color = \"red\";\n                }\n            }\n            else {\n                // Hide wallet info when disconnected\n                walletAddress.textContent = \"\";\n                walletAddress.classList.add(\"hidden\");\n                networkStatus.textContent = \"\";\n                networkStatus.classList.add(\"hidden\");\n            }\n            return [2 /*return*/];\n        });\n    });\n}\nexport function connectWallet() {\n    return __awaiter(this, void 0, void 0, function () {\n        var result, error_1;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    console.log(\"Connect wallet called\");\n                    _a.label = 1;\n                case 1:\n                    _a.trys.push([1, 5, , 7]);\n                    // Always ensure we have a fresh provider reference\n                    return [4 /*yield*/, waitForMetaMaskProvider()];\n                case 2:\n                    // Always ensure we have a fresh provider reference\n                    _a.sent();\n                    if (!provider) {\n                        console.error(\"MetaMask not available after waiting\");\n                        alert(\"MetaMask not detected. Please install MetaMask to continue.\");\n                        return [2 /*return*/];\n                    }\n                    console.log(\"Provider found, requesting connection...\");\n                    return [4 /*yield*/, provider.request({\n                            method: \"wallet_requestPermissions\",\n                            params: [{ eth_accounts: {} }],\n                        })];\n                case 3:\n                    result = _a.sent();\n                    console.log(\"Permission result:\", result);\n                    // Store connection timestamp for our 7-day expiry rule\n                    localStorage.setItem(CONNECTION_TIME_KEY, Date.now().toString());\n                    // Update UI immediately after successful connection\n                    return [4 /*yield*/, updateWalletUI()];\n                case 4:\n                    // Update UI immediately after successful connection\n                    _a.sent();\n                    console.log(\"Wallet connection successful, connected account:\", provider.selectedAddress);\n                    return [3 /*break*/, 7];\n                case 5:\n                    error_1 = _a.sent();\n                    console.error(\"Full error object:\", error_1);\n                    if (error_1.code === 4001) {\n                        console.log(\"User rejected wallet connection\");\n                    }\n                    else if (error_1.code === -32002) {\n                        console.log(\"Connection request already pending\");\n                        alert(\"Connection request already pending. Please check MetaMask.\");\n                    }\n                    else {\n                        console.error(\"Error connecting wallet:\", error_1);\n                        alert(\"Failed to connect wallet: \".concat(error_1.message || \"Unknown error\"));\n                    }\n                    // Ensure UI is updated even on error\n                    return [4 /*yield*/, updateWalletUI()];\n                case 6:\n                    // Ensure UI is updated even on error\n                    _a.sent();\n                    return [3 /*break*/, 7];\n                case 7: return [2 /*return*/];\n            }\n        });\n    });\n}\nexport function checkExistingConnection() {\n    return __awaiter(this, void 0, void 0, function () {\n        var permissions, accountsPermission, accounts, error_2;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    _a.trys.push([0, 7, , 8]);\n                    if (!!provider) return [3 /*break*/, 2];\n                    return [4 /*yield*/, waitForMetaMaskProvider()];\n                case 1:\n                    _a.sent();\n                    _a.label = 2;\n                case 2:\n                    if (!provider) {\n                        console.log(\"MetaMask not available for connection check\");\n                        return [2 /*return*/, false];\n                    }\n                    return [4 /*yield*/, provider.request({\n                            method: \"wallet_getPermissions\",\n                        })];\n                case 3:\n                    permissions = (_a.sent());\n                    accountsPermission = permissions.find(function (permission) { return permission.parentCapability === \"eth_accounts\"; });\n                    if (!accountsPermission) return [3 /*break*/, 6];\n                    return [4 /*yield*/, provider.request({\n                            method: \"eth_accounts\",\n                        })];\n                case 4:\n                    accounts = (_a.sent());\n                    if (!(accounts.length > 0)) return [3 /*break*/, 6];\n                    console.log(\"Existing connection found:\", accounts[0]);\n                    return [4 /*yield*/, updateWalletUI()];\n                case 5:\n                    _a.sent();\n                    return [2 /*return*/, true];\n                case 6: return [2 /*return*/, false];\n                case 7:\n                    error_2 = _a.sent();\n                    console.error(\"Error checking existing connection:\", error_2);\n                    return [2 /*return*/, false];\n                case 8: return [2 /*return*/];\n            }\n        });\n    });\n}\nexport function disconnectWallet() {\n    return __awaiter(this, void 0, void 0, function () {\n        var fetchError_1, revokeError_1, error_3;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    console.log(\"Disconnecting wallet...\");\n                    _a.label = 1;\n                case 1:\n                    _a.trys.push([1, 11, , 13]);\n                    if (!(provider === null || provider === void 0 ? void 0 : provider.isConnected())) return [3 /*break*/, 5];\n                    _a.label = 2;\n                case 2:\n                    _a.trys.push([2, 4, , 5]);\n                    return [4 /*yield*/, fetch(\"/api/wallet/disconnect\", {\n                            method: \"POST\",\n                            headers: {\n                                \"Content-Type\": \"application/json\",\n                            },\n                            body: JSON.stringify({\n                                address: provider.selectedAddress,\n                            }),\n                        })];\n                case 3:\n                    _a.sent();\n                    return [3 /*break*/, 5];\n                case 4:\n                    fetchError_1 = _a.sent();\n                    console.warn(\"Failed to notify backend of wallet disconnection:\", fetchError_1);\n                    return [3 /*break*/, 5];\n                case 5:\n                    // Clear connection timestamp\n                    localStorage.removeItem(CONNECTION_TIME_KEY);\n                    if (!provider) return [3 /*break*/, 9];\n                    _a.label = 6;\n                case 6:\n                    _a.trys.push([6, 8, , 9]);\n                    return [4 /*yield*/, provider.request({\n                            method: \"wallet_revokePermissions\",\n                            params: [{ eth_accounts: {} }],\n                        })];\n                case 7:\n                    _a.sent();\n                    console.log(\"Wallet permissions revoked successfully\");\n                    return [3 /*break*/, 9];\n                case 8:\n                    revokeError_1 = _a.sent();\n                    console.warn(\"Could not revoke permissions:\", revokeError_1);\n                    return [3 /*break*/, 9];\n                case 9:\n                    // Clear our local provider state\n                    provider = null;\n                    return [4 /*yield*/, updateWalletUI()];\n                case 10:\n                    _a.sent();\n                    console.log(\"Wallet disconnected successfully\");\n                    return [3 /*break*/, 13];\n                case 11:\n                    error_3 = _a.sent();\n                    console.error(\"Error disconnecting wallet:\", error_3);\n                    // Always clear local state even if there's an error\n                    localStorage.removeItem(CONNECTION_TIME_KEY);\n                    provider = null;\n                    return [4 /*yield*/, updateWalletUI()];\n                case 12:\n                    _a.sent();\n                    return [3 /*break*/, 13];\n                case 13: return [2 /*return*/];\n            }\n        });\n    });\n}\n/** Wait until MetaMask injects the provider per EIP-6963 */\nexport function waitForMetaMaskProvider() {\n    return __awaiter(this, void 0, void 0, function () {\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    console.log(\"Waiting for MetaMask provider...\");\n                    if (!!provider) return [3 /*break*/, 2];\n                    return [4 /*yield*/, detectEthereumProvider({\n                            mustBeMetaMask: true,\n                            silent: false,\n                            timeout: 5000, // 5 second timeout\n                        })];\n                case 1:\n                    provider = (_a.sent());\n                    if (!provider) {\n                        console.error(\"MetaMask not detected after waiting\");\n                        return [2 /*return*/];\n                    }\n                    console.log(\"MetaMask provider detected, setting up listeners...\");\n                    // Remove existing listeners to avoid duplicates\n                    if (provider.removeAllListeners) {\n                        provider.removeAllListeners();\n                    }\n                    // wire up listeners with proper args signature\n                    provider.on(\"accountsChanged\", function () {\n                        var args = [];\n                        for (var _i = 0; _i < arguments.length; _i++) {\n                            args[_i] = arguments[_i];\n                        }\n                        var accounts = args[0];\n                        console.log(\"accountsChanged event:\", accounts);\n                        handleAccountsChanged(accounts);\n                    });\n                    provider.on(\"chainChanged\", function () {\n                        var args = [];\n                        for (var _i = 0; _i < arguments.length; _i++) {\n                            args[_i] = arguments[_i];\n                        }\n                        var chainId = args[0];\n                        console.log(\"chainChanged event:\", chainId);\n                        handleChainChanged(chainId);\n                    });\n                    provider.on(\"connect\", function () {\n                        var args = [];\n                        for (var _i = 0; _i < arguments.length; _i++) {\n                            args[_i] = arguments[_i];\n                        }\n                        console.log(\"MetaMask connected event\", args[0]);\n                        updateWalletUI();\n                    });\n                    provider.on(\"disconnect\", function () {\n                        var args = [];\n                        for (var _i = 0; _i < arguments.length; _i++) {\n                            args[_i] = arguments[_i];\n                        }\n                        console.log(\"MetaMask disconnected event\", args[0]);\n                        updateWalletUI();\n                    });\n                    return [3 /*break*/, 3];\n                case 2:\n                    console.log(\"Provider already exists\");\n                    _a.label = 3;\n                case 3: return [2 /*return*/];\n            }\n        });\n    });\n}\nfunction handleAccountsChanged(accounts) {\n    console.log(\"Accounts changed (detected):\", accounts);\n    if (accounts.length === 0) {\n        // User disconnected their wallet from MetaMask interface\n        // Clear connection timestamp since user disconnected\n        localStorage.removeItem(CONNECTION_TIME_KEY);\n        provider = null;\n    }\n    updateWalletUI();\n}\nfunction handleChainChanged(chainId) {\n    console.log(\"Chain changed (detected) to:\", chainId);\n    updateNetworkStatus(chainId);\n}\n// Auto-reconnect function to be called on page load\nexport function autoReconnectWallet() {\n    return __awaiter(this, void 0, void 0, function () {\n        var connectionTime, timeDiff, sevenDaysInMs, error_4, connected;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    connectionTime = localStorage.getItem(CONNECTION_TIME_KEY);\n                    if (!connectionTime) return [3 /*break*/, 8];\n                    timeDiff = Date.now() - parseInt(connectionTime);\n                    sevenDaysInMs = 7 * 24 * 60 * 60 * 1000;\n                    if (!(timeDiff > sevenDaysInMs)) return [3 /*break*/, 8];\n                    // Connection is older than 7 days, clear it and don't auto-reconnect\n                    localStorage.removeItem(CONNECTION_TIME_KEY);\n                    console.log(\"Connection expired (older than 7 days)\");\n                    _a.label = 1;\n                case 1:\n                    _a.trys.push([1, 6, , 7]);\n                    if (!!provider) return [3 /*break*/, 3];\n                    return [4 /*yield*/, waitForMetaMaskProvider()];\n                case 2:\n                    _a.sent();\n                    _a.label = 3;\n                case 3:\n                    if (!provider) return [3 /*break*/, 5];\n                    return [4 /*yield*/, provider.request({\n                            method: \"wallet_revokePermissions\",\n                            params: [{ eth_accounts: {} }],\n                        })];\n                case 4:\n                    _a.sent();\n                    _a.label = 5;\n                case 5: return [3 /*break*/, 7];\n                case 6:\n                    error_4 = _a.sent();\n                    console.warn(\"Could not revoke expired permissions:\", error_4);\n                    return [3 /*break*/, 7];\n                case 7: return [2 /*return*/];\n                case 8: return [4 /*yield*/, checkExistingConnection()];\n                case 9:\n                    connected = _a.sent();\n                    if (!connected) {\n                        console.log(\"No existing wallet connection found\");\n                        // Clear timestamp if no permissions exist\n                        localStorage.removeItem(CONNECTION_TIME_KEY);\n                    }\n                    return [2 /*return*/];\n            }\n        });\n    });\n}\n// Helper function to check if wallet is actually connected (permissions + accounts)\nexport function isWalletConnected() {\n    return __awaiter(this, void 0, void 0, function () {\n        var permissions, accountsPermission, accounts, connected, error_5;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    if (!provider) {\n                        console.log(\"No provider available for connection check\");\n                        return [2 /*return*/, false];\n                    }\n                    _a.label = 1;\n                case 1:\n                    _a.trys.push([1, 4, , 5]);\n                    // First check if provider thinks it's connected\n                    if (!provider.isConnected() || !provider.selectedAddress) {\n                        console.log(\"Provider not connected or no selected address\");\n                        return [2 /*return*/, false];\n                    }\n                    return [4 /*yield*/, provider.request({\n                            method: \"wallet_getPermissions\",\n                        })];\n                case 2:\n                    permissions = (_a.sent());\n                    accountsPermission = permissions.find(function (permission) { return permission.parentCapability === \"eth_accounts\"; });\n                    if (!accountsPermission) {\n                        console.log(\"No eth_accounts permission found\");\n                        return [2 /*return*/, false];\n                    }\n                    return [4 /*yield*/, provider.request({\n                            method: \"eth_accounts\",\n                        })];\n                case 3:\n                    accounts = (_a.sent());\n                    connected = accounts.length > 0;\n                    console.log(\"Wallet connection check result:\", connected, \"accounts:\", accounts.length);\n                    return [2 /*return*/, connected];\n                case 4:\n                    error_5 = _a.sent();\n                    console.error(\"Error checking wallet connection:\", error_5);\n                    return [2 /*return*/, false];\n                case 5: return [2 /*return*/];\n            }\n        });\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === \"function\" ? Iterator : Object).prototype);\n    return g.next = verb(0), g[\"throw\"] = verb(1), g[\"return\"] = verb(2), typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nimport { provider } from \"./metamask\";\nimport utils from \"./utils\";\nfunction init() {\n    var _this = this;\n    utils.watchElementsOfClass(\"back-button\", function (button) {\n        button.addEventListener(\"click\", function () {\n            utils.loadContent({\n                apiUrl: \"/api/html/toptraders\",\n                browserUrl: \"/toptraders\",\n                title: \"Top Traders\",\n            });\n        });\n    });\n    utils.watchElementsOfClass(\"favorite-button\", function (button) {\n        console.log(\"Found favorite button\");\n        button.addEventListener(\"click\", function () { return __awaiter(_this, void 0, void 0, function () {\n            var favoriteAddr, walletAddress, originalText, isFavorited, icon, error_1;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        favoriteAddr = button.getAttribute(\"data-address\");\n                        console.log(\"Favoriting trader:\", favoriteAddr);\n                        if (!favoriteAddr) {\n                            console.error(\"No trader address found\");\n                            return [2 /*return*/];\n                        }\n                        // Check if wallet is connected using MetaMask provider\n                        if (!provider || !provider.selectedAddress) {\n                            utils.showNotification(\"Please connect your wallet first\", \"error\");\n                            return [2 /*return*/];\n                        }\n                        walletAddress = provider.selectedAddress;\n                        originalText = button.textContent;\n                        button.textContent = \"Processing...\";\n                        _a.label = 1;\n                    case 1:\n                        _a.trys.push([1, 3, 4, 5]);\n                        isFavorited = button.classList.contains(\"favorited\");\n                        if (isFavorited) {\n                            // TODO: Implement unfavorite functionality\n                            utils.showNotification(\"Unfavorite functionality not yet implemented\", \"info\");\n                            return [2 /*return*/];\n                        }\n                        // Send favorite request to server\n                        return [4 /*yield*/, favoriteTrader(walletAddress, favoriteAddr)];\n                    case 2:\n                        // Send favorite request to server\n                        _a.sent();\n                        // Toggle favorite state on success\n                        button.classList.add(\"favorited\");\n                        icon = button.querySelector(\"svg path:last-child\");\n                        // Filled heart icon\n                        icon === null || icon === void 0 ? void 0 : icon.setAttribute(\"d\", \"M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z\");\n                        utils.showNotification(\"Trader favorited successfully\", \"success\");\n                        return [3 /*break*/, 5];\n                    case 3:\n                        error_1 = _a.sent();\n                        console.error(\"Error favoriting trader:\", error_1);\n                        utils.showNotification(\"Failed to favorite trader\", \"error\");\n                        return [3 /*break*/, 5];\n                    case 4:\n                        // Re-enable button\n                        button.textContent = originalText;\n                        return [7 /*endfinally*/];\n                    case 5: return [2 /*return*/];\n                }\n            });\n        }); });\n    });\n}\nfunction favoriteTrader(followerAddr, favoriteAddr) {\n    return __awaiter(this, void 0, void 0, function () {\n        var timestamp, message, signature, response, errorData, result, error_2;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    _a.trys.push([0, 6, , 7]);\n                    timestamp = Date.now();\n                    message = \"Favorite trader \".concat(favoriteAddr, \" for \").concat(followerAddr, \" at \").concat(timestamp);\n                    // Request wallet signature using MetaMask provider\n                    if (!provider) {\n                        throw new Error(\"MetaMask provider not available\");\n                    }\n                    return [4 /*yield*/, provider.request({\n                            method: \"personal_sign\",\n                            params: [message, followerAddr],\n                        })];\n                case 1:\n                    signature = (_a.sent());\n                    if (!signature) {\n                        throw new Error(\"Failed to get wallet signature\");\n                    }\n                    return [4 /*yield*/, fetch(\"/api/traders/\".concat(followerAddr, \"/favorite_trader\"), {\n                            method: \"POST\",\n                            headers: {\n                                \"Content-Type\": \"application/json\",\n                            },\n                            body: JSON.stringify({\n                                favoriteAddr: favoriteAddr,\n                                signature: signature,\n                                message: message,\n                                timestamp: timestamp,\n                            }),\n                        })];\n                case 2:\n                    response = _a.sent();\n                    if (!!response.ok) return [3 /*break*/, 4];\n                    return [4 /*yield*/, response.json()];\n                case 3:\n                    errorData = _a.sent();\n                    throw new Error(errorData.error || \"Failed to favorite trader\");\n                case 4: return [4 /*yield*/, response.json()];\n                case 5:\n                    result = _a.sent();\n                    console.log(\"Favorite trader response:\", result);\n                    return [3 /*break*/, 7];\n                case 6:\n                    error_2 = _a.sent();\n                    console.error(\"Error in favoriteTrader:\", error_2);\n                    throw error_2;\n                case 7: return [2 /*return*/];\n            }\n        });\n    });\n}\nvar profile = {\n    init: init,\n};\nexport default profile;\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === \"function\" ? Iterator : Object).prototype);\n    return g.next = verb(0), g[\"throw\"] = verb(1), g[\"return\"] = verb(2), typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nimport { provider } from \"./metamask\";\n// Number formatting utilities\nfunction formatNumber(value, decimals) {\n    if (decimals === void 0) { decimals = 2; }\n    var num = Number(value) || 0;\n    return num.toFixed(decimals);\n}\nfunction formatCurrency(value, currency) {\n    if (currency === void 0) { currency = \"$\"; }\n    var num = Number(value) || 0;\n    return \"\".concat(currency).concat(num.toLocaleString());\n}\nfunction formatPercentage(value) {\n    var num = Number(value) || 0;\n    var sign = num >= 0 ? \"+\" : \"\";\n    return \"\".concat(sign).concat(num.toFixed(2), \"%\");\n}\nfunction truncateAddress(address, startLength, endLength) {\n    if (startLength === void 0) { startLength = 6; }\n    if (endLength === void 0) { endLength = 4; }\n    if (!address || address.length < startLength + endLength) {\n        return address;\n    }\n    return \"\".concat(address.slice(0, startLength), \"...\").concat(address.slice(-endLength));\n}\nfunction isValidAddress(address) {\n    return /^0x[a-fA-F0-9]{40}$/.test(address);\n}\nfunction formatTimestamp(timestamp) {\n    var date = new Date(timestamp);\n    return date.toLocaleString();\n}\nfunction timeAgo(timestamp) {\n    var now = new Date();\n    var past = new Date(timestamp);\n    var diffInSeconds = Math.floor((now.getTime() - past.getTime()) / 1000);\n    if (diffInSeconds < 60)\n        return \"\".concat(diffInSeconds, \"s ago\");\n    if (diffInSeconds < 3600)\n        return \"\".concat(Math.floor(diffInSeconds / 60), \"m ago\");\n    if (diffInSeconds < 86400)\n        return \"\".concat(Math.floor(diffInSeconds / 3600), \"h ago\");\n    return \"\".concat(Math.floor(diffInSeconds / 86400), \"d ago\");\n}\nfunction createElement(tag, className, innerHTML) {\n    var element = document.createElement(tag);\n    if (className)\n        element.className = className;\n    if (innerHTML)\n        element.innerHTML = innerHTML;\n    return element;\n}\nfunction showToast(message, type) {\n    if (type === void 0) { type = \"info\"; }\n    // TODO: Implement toast notification system\n    console.log(\"[\".concat(type.toUpperCase(), \"] \").concat(message));\n}\nfunction getPlatformIcon(platform) {\n    if (!platform) {\n        return '<span style=\"color:#666;\">-</span>';\n    }\n    var platformLower = platform.toLowerCase();\n    switch (platformLower) {\n        case \"gmx\":\n            return \"\\n        <svg width=\\\"24\\\" height=\\\"24\\\" viewBox=\\\"0 0 30 30\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\">\\n          <defs>\\n            <linearGradient id=\\\"gmx-gradient-watched\\\" x1=\\\"0%\\\" y1=\\\"0%\\\" x2=\\\"100%\\\" y2=\\\"100%\\\">\\n              <stop offset=\\\"0%\\\" style=\\\"stop-color:#4f46e5;stop-opacity:1\\\" />\\n              <stop offset=\\\"100%\\\" style=\\\"stop-color:#06b6d4;stop-opacity:1\\\" />\\n            </linearGradient>\\n          </defs>\\n          <path fill=\\\"url(#gmx-gradient-watched)\\\" transform=\\\"translate(-525.667 -696) scale(1)\\\" d=\\\"m555.182 717.462-14.735-21.462-14.78 21.462h20.592l-5.812-8.191-2.883 4.256h-3.064l5.949-8.557 8.6 12.493z\\\"/>\\n        </svg>\\n      \";\n        case \"dydx\":\n            return \"<span style=\\\"font-size:0.75rem;color:#888;\\\">DYDX</span>\";\n        case \"hyperliquid\":\n            return \"<span style=\\\"font-size:0.75rem;color:#888;\\\">HL</span>\";\n        default:\n            return \"<span style=\\\"font-size:0.75rem;color:#888;\\\">\".concat(platform.toUpperCase(), \"</span>\");\n    }\n}\nfunction generateIconColor(address) {\n    var hash = address.slice(2, 8);\n    var r = parseInt(hash.slice(0, 2), 16);\n    var g = parseInt(hash.slice(2, 4), 16);\n    var b = parseInt(hash.slice(4, 6), 16);\n    return \"rgb(\".concat(r, \", \").concat(g, \", \").concat(b, \")\");\n}\n// Helper function to update content with optional URL change\nfunction loadContent(_a) {\n    return __awaiter(this, arguments, void 0, function (_b) {\n        var contentDiv_1, walletAddress, headers, response, html, contentDiv, error_1;\n        var apiUrl = _b.apiUrl, browserUrl = _b.browserUrl, title = _b.title, walletAddr = _b.walletAddr, content = _b.content, _c = _b.updateUrl, updateUrl = _c === void 0 ? true : _c;\n        return __generator(this, function (_d) {\n            switch (_d.label) {\n                case 0:\n                    _d.trys.push([0, 3, , 4]);\n                    if (content) {\n                        contentDiv_1 = document.querySelector(\".index-content\");\n                        if (contentDiv_1) {\n                            contentDiv_1.innerHTML = content;\n                        }\n                        document.title = title;\n                        // Update URL if requested and browserUrl is provided\n                        if (updateUrl && browserUrl) {\n                            window.history.pushState({}, title, browserUrl);\n                        }\n                        return [2 /*return*/];\n                    }\n                    if (!apiUrl) {\n                        throw new Error(\"No API URL or content provided\");\n                    }\n                    showLoadingState();\n                    walletAddress = walletAddr || (provider === null || provider === void 0 ? void 0 : provider.selectedAddress);\n                    headers = {\n                        \"Content-Type\": \"application/json\",\n                    };\n                    // Add wallet address to headers if available\n                    if (walletAddress) {\n                        headers[\"x-wallet-address\"] = walletAddress;\n                    }\n                    return [4 /*yield*/, fetch(apiUrl, {\n                            method: \"GET\",\n                            headers: headers,\n                        })];\n                case 1:\n                    response = _d.sent();\n                    if (!response.ok) {\n                        throw new Error(\"HTTP error! status: \".concat(response.status));\n                    }\n                    return [4 /*yield*/, response.text()];\n                case 2:\n                    html = _d.sent();\n                    contentDiv = document.querySelector(\".index-content\");\n                    if (contentDiv) {\n                        contentDiv.innerHTML = html;\n                    }\n                    document.title = title;\n                    // Update browser URL if requested and browserUrl is provided\n                    if (updateUrl && browserUrl) {\n                        window.history.pushState({}, title, browserUrl);\n                    }\n                    return [3 /*break*/, 4];\n                case 3:\n                    error_1 = _d.sent();\n                    console.error(\"Error loading content:\", error_1);\n                    showNotification(\"Error loading content\", \"error\");\n                    return [3 /*break*/, 4];\n                case 4: return [2 /*return*/];\n            }\n        });\n    });\n}\nfunction showLoadingState() {\n    var contentArea = document.querySelector(\".index-content\");\n    if (contentArea) {\n        contentArea.innerHTML = \"\\n      <div class=\\\"loading-container\\\">\\n        <div class=\\\"loading-spinner\\\"></div>\\n        <p>Loading...</p>\\n      </div>\\n    \";\n    }\n}\nfunction watchElementsOfClass(className, onElementLoad) {\n    // Handle existing elements on initial load\n    var existingElements = document.querySelectorAll(\".\".concat(className));\n    existingElements.forEach(function (el) { return onElementLoad(el); });\n    // Set up a MutationObserver for newly added elements\n    var observer = new MutationObserver(function (mutations) {\n        mutations.forEach(function (mutation) {\n            mutation.addedNodes.forEach(function (node) {\n                if (node.nodeType === Node.ELEMENT_NODE) {\n                    var element = node;\n                    // Check if the added node has our class\n                    if (element.classList.contains(className)) {\n                        onElementLoad(element);\n                    }\n                    // Check any child elements\n                    element.querySelectorAll(\".\".concat(className)).forEach(function (child) {\n                        onElementLoad(child);\n                    });\n                }\n            });\n        });\n    });\n    observer.observe(document.body, {\n        childList: true,\n        subtree: true,\n    });\n}\nfunction showNotification(message, type) {\n    // Simple notification implementation\n    // You can replace this with your preferred notification library\n    console.log(\"\".concat(type.toUpperCase(), \": \").concat(message));\n    // Optional: Create a simple toast notification\n    var notification = document.createElement(\"div\");\n    notification.className = \"notification \".concat(type);\n    notification.textContent = message;\n    notification.style.cssText = \"\\n    position: fixed;\\n    top: 20px;\\n    right: 20px;\\n    padding: 12px 20px;\\n    background: \".concat(type === \"success\" ? \"#10b981\" : type === \"error\" ? \"#ef4444\" : \"#3b82f6\", \";\\n    color: white;\\n    border-radius: 8px;\\n    z-index: 1000;\\n    transition: opacity 0.3s ease;\\n  \");\n    document.body.appendChild(notification);\n    setTimeout(function () {\n        notification.style.opacity = \"0\";\n        setTimeout(function () { return notification.remove(); }, 300);\n    }, 3000);\n}\nvar utils = {\n    formatNumber: formatNumber,\n    formatCurrency: formatCurrency,\n    formatPercentage: formatPercentage,\n    truncateAddress: truncateAddress,\n    isValidAddress: isValidAddress,\n    formatTimestamp: formatTimestamp,\n    timeAgo: timeAgo,\n    createElement: createElement,\n    showToast: showToast,\n    getPlatformIcon: getPlatformIcon,\n    generateIconColor: generateIconColor,\n    loadContent: loadContent,\n    watchElementsOfClass: watchElementsOfClass,\n    showNotification: showNotification,\n};\nexport default utils;\n","import utils from \"./utils\";\nfunction init() {\n    utils.watchElementsOfClass(\"select-trader\", function (button) {\n        button.addEventListener(\"click\", function () {\n            console.log(\"Select trader button clicked\");\n        });\n    });\n}\nvar watchlist = {\n    init: init,\n};\nexport default watchlist;\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === \"function\" ? Iterator : Object).prototype);\n    return g.next = verb(0), g[\"throw\"] = verb(1), g[\"return\"] = verb(2), typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\n// Import only what you need from each module\nimport { autoReconnectWallet, connectWallet, disconnectWallet, isWalletConnected, provider, updateWalletUI, } from \"./metamask\";\nimport profile from \"./profile\";\nimport utils from \"./utils\";\nimport watchlist from \"./watchlist\";\nconsole.log(\"DEXMT JS file loaded\");\n// Main application initialization\ndocument.addEventListener(\"DOMContentLoaded\", function () { return __awaiter(void 0, void 0, void 0, function () {\n    var error_1, topTradersBtn, myWatchListBtn, connectButton;\n    return __generator(this, function (_a) {\n        switch (_a.label) {\n            case 0:\n                console.log(\"DOM loaded, setting up DEXMT...\");\n                profile.init();\n                watchlist.init();\n                _a.label = 1;\n            case 1:\n                _a.trys.push([1, 4, , 5]);\n                // Auto-reconnect wallet if previously connected\n                return [4 /*yield*/, autoReconnectWallet()];\n            case 2:\n                // Auto-reconnect wallet if previously connected\n                _a.sent();\n                // sync the Connect/Disconnect button to real wallet state\n                return [4 /*yield*/, updateWalletUI()];\n            case 3:\n                // sync the Connect/Disconnect button to real wallet state\n                _a.sent();\n                return [3 /*break*/, 5];\n            case 4:\n                error_1 = _a.sent();\n                console.error(\"Error during initialization:\", error_1);\n                utils.showToast(\"Initialization error\", \"error\");\n                return [3 /*break*/, 5];\n            case 5: \n            // Load content based on current URL\n            return [4 /*yield*/, loadContentForCurrentPage()];\n            case 6:\n                // Load content based on current URL\n                _a.sent();\n                topTradersBtn = document.getElementById(\"topTradersBtn\");\n                myWatchListBtn = document.getElementById(\"myWatchListBtn\");\n                if (topTradersBtn) {\n                    topTradersBtn.addEventListener(\"click\", function () { return __awaiter(void 0, void 0, void 0, function () {\n                        return __generator(this, function (_a) {\n                            switch (_a.label) {\n                                case 0: return [4 /*yield*/, utils.loadContent({\n                                        apiUrl: \"/api/html/toptraders\",\n                                        browserUrl: \"/toptraders\",\n                                        title: \"Top Traders\",\n                                    })];\n                                case 1:\n                                    _a.sent();\n                                    return [2 /*return*/];\n                            }\n                        });\n                    }); });\n                }\n                if (myWatchListBtn) {\n                    //FIXME: Authenticate user selected address before loading watchlist\n                    myWatchListBtn.addEventListener(\"click\", function () { return __awaiter(void 0, void 0, void 0, function () {\n                        var walletAddress;\n                        return __generator(this, function (_a) {\n                            switch (_a.label) {\n                                case 0:\n                                    walletAddress = provider === null || provider === void 0 ? void 0 : provider.selectedAddress;\n                                    return [4 /*yield*/, utils.loadContent({\n                                            apiUrl: \"/api/html/mywatchlist\",\n                                            browserUrl: \"/mywatchlist\",\n                                            title: \"My Watchlist\",\n                                            walletAddr: walletAddress || undefined,\n                                        })];\n                                case 1:\n                                    _a.sent();\n                                    return [2 /*return*/];\n                            }\n                        });\n                    }); });\n                }\n                // Add click listeners to trader rows\n                document.addEventListener(\"click\", function (event) { return __awaiter(void 0, void 0, void 0, function () {\n                    var traderRow, address, walletAddress, apiUrl;\n                    return __generator(this, function (_a) {\n                        switch (_a.label) {\n                            case 0:\n                                traderRow = event.target.closest(\"tr\");\n                                if (!traderRow)\n                                    return [2 /*return*/];\n                                address = traderRow.getAttribute(\"address\");\n                                if (!address)\n                                    return [2 /*return*/];\n                                walletAddress = provider === null || provider === void 0 ? void 0 : provider.selectedAddress;\n                                apiUrl = \"/api/html/traderprofile?address=\".concat(encodeURIComponent(address));\n                                if (walletAddress) {\n                                    apiUrl += \"&userAddress=\".concat(encodeURIComponent(walletAddress));\n                                }\n                                return [4 /*yield*/, utils.loadContent({\n                                        apiUrl: apiUrl,\n                                        browserUrl: \"/traderprofile?address=\" + encodeURIComponent(address),\n                                        title: \"Trader Profile\",\n                                        walletAddr: walletAddress || undefined,\n                                    })];\n                            case 1:\n                                _a.sent();\n                                return [2 /*return*/];\n                        }\n                    });\n                }); });\n                connectButton = document.getElementById(\"connectButton\");\n                if (connectButton) {\n                    connectButton.addEventListener(\"click\", function () { return __awaiter(void 0, void 0, void 0, function () {\n                        var currentlyConnected;\n                        return __generator(this, function (_a) {\n                            switch (_a.label) {\n                                case 0: return [4 /*yield*/, isWalletConnected()];\n                                case 1:\n                                    currentlyConnected = _a.sent();\n                                    if (!currentlyConnected) return [3 /*break*/, 3];\n                                    return [4 /*yield*/, disconnectWallet()];\n                                case 2:\n                                    _a.sent();\n                                    return [3 /*break*/, 5];\n                                case 3: return [4 /*yield*/, connectWallet()];\n                                case 4:\n                                    _a.sent();\n                                    _a.label = 5;\n                                case 5: return [2 /*return*/];\n                            }\n                        });\n                    }); });\n                }\n                console.log(\"DEXMT setup complete\");\n                return [2 /*return*/];\n        }\n    });\n}); });\n// Function to load content based on current URL\nfunction loadContentForCurrentPage() {\n    return __awaiter(this, void 0, void 0, function () {\n        var currentPath, searchParams, walletAddress, _a, address, apiUrl, error_2;\n        return __generator(this, function (_b) {\n            switch (_b.label) {\n                case 0:\n                    currentPath = window.location.pathname;\n                    searchParams = new URLSearchParams(window.location.search);\n                    walletAddress = provider === null || provider === void 0 ? void 0 : provider.selectedAddress;\n                    _b.label = 1;\n                case 1:\n                    _b.trys.push([1, 13, , 14]);\n                    _a = currentPath;\n                    switch (_a) {\n                        case \"/toptraders\": return [3 /*break*/, 2];\n                        case \"/mywatchlist\": return [3 /*break*/, 4];\n                        case \"/traderprofile\": return [3 /*break*/, 6];\n                    }\n                    return [3 /*break*/, 11];\n                case 2: return [4 /*yield*/, utils.loadContent({\n                        apiUrl: \"/api/html/toptraders\",\n                        title: \"Top Traders\",\n                        updateUrl: false, // Don't update URL on initial page load\n                    })];\n                case 3:\n                    _b.sent();\n                    return [3 /*break*/, 12];\n                case 4: return [4 /*yield*/, utils.loadContent({\n                        apiUrl: \"/api/html/mywatchlist\",\n                        title: \"My Watchlist\",\n                        walletAddr: walletAddress || undefined,\n                        updateUrl: false, // Don't update URL on initial page load\n                    })];\n                case 5:\n                    _b.sent();\n                    return [3 /*break*/, 12];\n                case 6:\n                    address = searchParams.get(\"address\");\n                    if (!address) return [3 /*break*/, 8];\n                    apiUrl = \"/api/html/traderprofile?address=\".concat(encodeURIComponent(address));\n                    if (walletAddress) {\n                        apiUrl += \"&userAddress=\".concat(encodeURIComponent(walletAddress));\n                    }\n                    return [4 /*yield*/, utils.loadContent({\n                            apiUrl: apiUrl,\n                            title: \"Trader Profile\",\n                            walletAddr: walletAddress || undefined,\n                            updateUrl: false, // Don't update URL on initial page load\n                        })];\n                case 7:\n                    _b.sent();\n                    return [3 /*break*/, 10];\n                case 8: return [4 /*yield*/, utils.loadContent({\n                        title: \"Trader Profile\",\n                        content: '<div class=\"error-message\">Trader address is required</div>',\n                        updateUrl: false,\n                    })];\n                case 9:\n                    _b.sent();\n                    _b.label = 10;\n                case 10: return [3 /*break*/, 12];\n                case 11: \n                // For root or unknown paths, don't load anything (let redirect handle it)\n                return [3 /*break*/, 12];\n                case 12: return [3 /*break*/, 14];\n                case 13:\n                    error_2 = _b.sent();\n                    console.error(\"Error loading initial content:\", error_2);\n                    return [3 /*break*/, 14];\n                case 14: return [2 /*return*/];\n            }\n        });\n    });\n}\n// Global error handler\nwindow.addEventListener(\"error\", function (event) {\n    console.error(\"Global error:\", event.error);\n    utils.showToast(\"An error occurred. Please refresh the page.\", \"error\");\n});\n// Export for debugging/compatibility\nwindow.DEXMT = {\n    version: \"1.0.0\",\n    initialized: true,\n};\n"],"names":[],"sourceRoot":""}